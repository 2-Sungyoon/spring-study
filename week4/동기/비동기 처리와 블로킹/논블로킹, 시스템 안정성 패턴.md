# 📅 [week 4] 동기/비동기 처리와 블로킹/논블로킹, 시스템 안정성 패턴

## 🎯 학습 목표
- **개념 확립:** 동기(Synchronous)와 비동기(Asynchronous), 블로킹(Blocking)과 논블로킹(Non-blocking)의 차이를 명확히 구분함
- **Spring Async:** `@Async`의 내부 동작 원리(AOP Proxy)와 `ThreadPoolTaskExecutor`의 스레드 관리 메커니즘을 이해함
- **안정성 패턴:** 외부 시스템 장애 시 내 서버를 보호하기 위한 타임아웃, 벌크헤드, 서킷 브레이커 패턴을 학습함

---

## 📚 사전 지식: 핵심 용어 (Terminology)
- **Context Switching (문맥 교환):** CPU가 현재 실행 중인 스레드를 멈추고, 다른 스레드를 실행하기 위해 상태를 저장/복구하는 과정. 스레드가 과도하게 많으면 이 비용으로 인해 성능이 저하됨
- **AOP Proxy:** 스프링 빈을 감싸고 있는 가짜 객체. `@Async`가 붙은 메서드 호출 시, 프록시가 요청을 가로채 별도의 스레드에 작업을 할당함

---

## 📝 주요 개념 정리

### 1. 동기/비동기 vs 블로킹/논블로킹
두 개념은 관심사가 서로 다르다

#### A. 동기 vs 비동기 (Synchronous vs Asynchronous)
"작업의 완료를 누가 신경 쓰는가?"에 대한 구분
- **동기(Synchronous):**
  - 호출자(Caller)가 피호출자(Callee)의 작업이 끝날 때까지 기다리거나, 끝났는지 계속 확인함
  - **특징:** 작업의 순서가 보장됨 (A 완료 후 B 실행)
- **비동기(Asynchronous):**
  - 호출자는 작업을 맡기고(Start), 작업 완료 여부를 신경 쓰지 않고 즉시 다음 일을 수행함
  - **특징:** 작업 결과는 나중에 콜백(Callback)이나 퓨처(Future)를 통해 받음. 작업 순서가 보장되지 않음

#### B. 블로킹 vs 논블로킹 (Blocking vs Non-blocking)
"제어권(Control)을 바로 돌려주는가?"에 대한 구분
- **블로킹(Blocking):**
  - 호출된 함수가 작업을 마칠 때까지 제어권을 가지고 놓아주지 않음
  - 호출한 쪽은 대기(Wait) 상태가 됨
- **논블로킹(Non-blocking):**
  - 호출된 함수가 즉시 제어권을 리턴함
  - 호출한 쪽은 멈추지 않고 다음 로직을 실행 가능함

### 2. 스프링의 비동기 처리: @Async와 AOP
스프링은 `@Async` 어노테이션을 통해 멀티스레딩을 추상화했음

- **동작 원리 (Proxy Pattern):**
  1. 클라이언트가 메서드를 호출하면 **프록시 객체**가 요청을 가로챔
  2. 프록시는 `TaskExecutor`(스레드 풀)에 작업을 제출(Submit)하고 즉시 리턴함
  3. 실제 로직은 별도의 스레드에서 수행됨

- **주의사항:**
  1. **private 메서드 불가:** 프록시 객체가 감싸야 하므로 `public` 메서드만 가능함
  2. **자가 호출(Self-invocation) 불가:** 같은 클래스 내부에서 `this.asyncMethod()` 호출 시 프록시를 거치지 않고 직접 호출하게 되어 **동기**로 동작함

### 3. 스레드 풀(Thread Pool)의 동작 메커니즘
`@EnableAsync`의 기본값인 `SimpleAsyncTaskExecutor`는 요청마다 스레드를 생성하므로 사용을 지양함. `ThreadPoolTaskExecutor`를 커스텀하여 사용해야 함

**[스레드 생성 순서]**
1. **CorePoolSize:** 요청 유입 시 기본 스레드 수만큼 생성함
2. **QueueCapacity:** Core 스레드가 모두 점유된 경우, 큐(Queue)에 작업을 적재함
3. **MaxPoolSize:** 큐까지 가득 찼을 때 Max 사이즈까지 스레드를 추가 생성함
4. **Reject:** Max 스레드와 큐가 모두 차면 요청을 거절(Exception)함

### 4. 시스템 안정성 패턴 (Resilience)
외부 서비스 장애 전파를 막기 위한 기술

- **타임아웃(Timeout):** 일정 시간 내 응답이 없으면 연결을 끊어 무한 대기를 방지함
- **벌크헤드(Bulkhead):** 자원을 격리함. A 서비스용 스레드 풀이 고갈되어도 B 서비스용 스레드 풀은 영향을 받지 않음
- **서킷 브레이커(Circuit Breaker):** 에러율이 임계치를 넘으면 요청을 즉시 차단(Fail-fast)하여 시스템 부하를 줄이고 회복 시간을 확보함

---

## 💻 코드 실습 및 분석

### 1. AsyncConfig (안전한 스레드 풀 설정)
```java
@Configuration
@EnableAsync // 비동기 기능 활성화
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 1. 기본 스레드 10개 유지
        executor.setCorePoolSize(10);
        // 2. 스레드가 다 차면 대기열 200개까지 저장
        executor.setQueueCapacity(200);
        // 3. 대기열도 다 차면 최대 50개까지 스레드 확장
        executor.setMaxPoolSize(50);
        executor.setThreadNamePrefix("Async-Executor-");
        
        // 빈 생성 시점에 스레드 풀 초기화
        executor.initialize();
        return executor;
    }

    // void 반환 메서드에서 예외 발생 시 처리 (필수)
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (throwable, method, obj) -> {
            System.err.println("비동기 예외 발생: " + throwable.getMessage());
            System.err.println("메서드명: " + method.getName());
        };
    }
}
```
### 2. 비동기 서비스 및 잘못된 사용 예시
```java
@Service
public class EmailService {

    // [올바른 예] 외부에서 호출 시 비동기 동작
    @Async
    public void sendEmail(String user) {
        System.out.println("이메일 전송 중... " + Thread.currentThread().getName());
    }

    // [잘못된 예] 자가 호출 (Self-invocation)
    public void registerUser(String user) {
        // 프록시를 거치지 않고 this(실제 객체)를 호출하므로 동기적으로 실행됨
        this.sendEmail(user); 
    }
}
```

---

## 💡 회고 및 질의응답
- Q. 동기와 비동기의 결정적인 차이점은?

동기: 호출자가 피호출자의 작업 완료를 기다리거나 확인함. 순서가 보장됨

비동기: 호출자가 작업을 맡기고 즉시 다른 일을 수행함. 작업 완료 여부를 직접 챙기지 않음

- Q. 스레드 풀의 QueueCapacity를 너무 크게 잡으면 발생하는 문제는?

큐는 메모리(RAM)에 적재되므로, 큐가 과도하게 크면 작업이 처리되지 않고 쌓이다가 OOM(Out Of Memory) 발생 위험이 있음. 또한 사용자는 응답을 받지 못한 채 긴 시간을 대기하게 됨

- Q. @Async 메서드 안에서 @Transactional의 동작 방식은?

동작은 하지만 상위 트랜잭션과 분리됨. 비동기 메서드는 별도의 스레드에서 실행되므로, 부모 트랜잭션의 커밋/롤백 여부와 무관하게 독립적인 트랜잭션 생명주기를 가짐

- Q. 외부 서비스 장애 시 시스템 보호 방법은?

타임아웃: 무한 대기 방지

벌크헤드: 서비스별 스레드 풀 격리로 장애 전파 차단

서킷 브레이커: 장애 지속 시 요청을 선제적으로 차단하여 리소스 보호
