# 📅 [week 4] 주제: Spring web scope

## 🎯 학습 목표
- 웹 스코프의 동작 원리를 이해한다.

- 스코프를 생명주기 기준으로 설명할 수 있다.

- 멀티스레드와 stateless 설계의 중요성을 이해한다.

- 프록시가 필요한 이유를 설명할 수 있다.
---

## 📝 주요 개념 정리
### 1. 웹스코프
**`웹 스코프는 HTTP 요청/세션 등 웹 환경의 생명주기에 맞춰 빈을 생성, 관리하는 스코프다.`**

종류 : 

- 요청 스코프
- 세션 스코프
- 애플리케이션 스코프

**요청 스코프**

**`HTTP 요청 하나 동안만 존재하는 빈`**

사용 이유 : 

- 스프링 웹 앱에서는 HTTP 요청 & 응답에 중점을 둠
    
    → 스프링에서 HTTP 요청과 관련해 빈의 생명주기 관리법을 제공한다면 효율적인 관리가 가능함
    

특징 : 

- 각각의 HTTP 요청마다 새로운 인스턴스를 생성
- 인스턴스를 생성한 요청에서만 해당 인스턴스 사용 가능
- 하나의 HTTP 요청은 하나의 스레드에 의해 처리되고, 해당 요청에서 생성된 요청 스코프 빈 인스턴스는 그 스레드만 접근 가능
    - 그렇기에 멀티스레드 문제는 발생 X
- 일반적으로 수명이 짧은 편
- 요청 완료 후, 인스턴스는 가비지 컬렉션이 됨

주의 사항 : 

- 인스턴스 생성 시, 시간이 오래 걸리는 로직을 넣으면 X
    - 요청 스코프는 매 요청 시, 새 객체를 만듦
    - 무거운 로직을 넣으면 서버 과부하 발생 가능
    - **가볍게 사용하자**
- 동기화 사용 X
    - 요청 스코프는 애초에 요청 하나당 하나의 객체, 객체 하나당 하나의 스레드만 사용
    - 굳이 `synchronized` 사용하여 불필요한 락 오버헤드 만들 필요 X

**싱글톤**

---

- 모든 요청이 같은 객체 공유
- 멀티스레드 문제 발생 가능

**요청 스코프**

---

- 요청마다 각각의 객체 생성
- 객체 공유 X
- 멀티스레드 문제 X

**세션 스코프**

**`사용자 세션 하나 동안 유지되는 빈 / 사용자 단위로 객체 공유`**

사용 이유 : 

- 세션 스코프는 요청 사이에서 데이터를 공유하기 위해 사용
    - ex) 로그인, 장바구니 등등..
- 요청이 바뀌어도 유지하고 싶은 데이터가 있을 경우 사용

특징 : 

- 특정 클라이언트에 대한 HTTP 세션이 생성될 때, 세션 스코프 빈의 인스턴스 생성
- 세션 스코프 빈 속성에 저장된 데이터는 해당 HTTP 세션 동안 클라이언트의 모든 요청에 재사용 가능
    - 여러 요청이 세션 스코프 빈의 인스턴스 공유 가능
- 동일한 클라이언트에 대해 동시에 여러 요청 실행 시, 멀티스레딩 문제 발생 가능
- 세션은 요청보다 수명이 긺
    - 상황에 따라 최후의 수단으로 동기화 사용해야 할 수도

주의 사항 : 

- `stateless` 상태를 유지하도록 해야 함
    - 세션에 정보를 두어 서버 메모리에 저장되면, 특정 서버 인스턴스에 종속됨
    - ex) 서버가 여러 대인 상황(로드 밸런싱)
        - 1. 사용자가 로그인함
        - 2. 세션 정보가 서버 A에 저장됨
        - 3. 서버 B에서는 해당 세션 정보에 접근 X → 로그인 유지 불가능
    - 결과 : `sticky session` 발생(로드밸런서가 해당 사용자에 대한 요청을 서버 A로 보내도록 고정함)
        - 서버 A 죽으면 세션 날아감
        - 서버 부하 분산이 제대로 이뤄지지 X
    
    → 세션을 서버 메모리에 두지 않고, 외부 저장소를 사용
    
- 세션에 데이터를 많이 보관하지 말자

**한줄 요약**

> 
> 
> 
> 세션 스코프는 편하지만, 상태를 서버 메모리에 오래 유지하기 때문에 동시성 / 확장성 / 성능 문제를 일으킬 수 있다.
> 

**애플리케이션 스코프**

**`웹 애플리케이션 전체에서 하나만 존재하는 빈`**

사용 이유 : 

- 웹 앱 전체에서 공통으로 사용하는 데이터를 관리하기 위해 사용

특징 : 

- 웹 앱 시작 시, 인스턴스 생성
- 애플리케이션이 종료될 때까지 유지
- 모든 사용자, 모든 요청이 동일한 인스턴스를 공유
- 멀티스레드 환경에서 동작
    - 여러 요청이 동시에 접근 가능

주의 사항 :

- 여러 스레드가 동시에 접근하므로 동시성 문제 발생 가능
    - 상태를 가진다면 동기화 고려 필요
- 전역 공유 객체이므로 불필요한 상태 저장을 피하는 것이 좋음
    - 읽기 전용(immutable)으로 사용하는 것이 좋음
- 세션과 마찬가지로 과도한 메모리 사용 주의

**싱글톤** 

---

- 스프링 컨테이너 기준으로 1개 생성
- 모든 스프링 환경(앱/웹)에서 사용 가능
- 생명주기 : 컨테이너 시작 ~ 종료
- 기준점 : ApplicationContext

**애플리케이션 스코프**

---

- 서블릿 컨텍스트(웹 앱) 기준으로 1개 생성
- 웹 앱에서만 사용 가능
- 생명주기 : 웹 앱 시작 ~ 종료
- 기준점 : ServletContext(HTTP 환경)


---

## 💻 코드 실습 및 분석
```java

```

---

## 💡 회고 및 질의응답
### 싱글톤이 request 빈을 주입하면 왜 프록시가 필요한가

- 싱글톤은 컨테이너 시작 시점에 한 번 생성
- 요청 빈은 요청이 와야 생성됨
- 즉, 싱글톤이 생성되는 시점에는 요청 빈 존재 X
- 그래서 스프링은 진짜 요청 빈을 바로 넣는 게 아니라, 가짜 객체(프록시)를 먼저 넣어둠
- 그리고 실제 요청이 들어올 때 진짜 요청 빈을 찾아 연결해줌
    
    → 웹 스코프에서는 proxyMode 필요
  
### QUIZ

https://gemini.google.com/share/fcd4fe0cdff6
