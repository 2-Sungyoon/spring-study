# 📅 [week 1] 스프링 부트 입문 및 스프링 핵심 원리 (IoC, AOP, PSA)

## 🎯 학습 목표
- **스프링 부트 서버 구조:** 내장 서버(Tomcat)와 JAR 빌드 방식의 기술적 변화를 이해한다.
- **웹 개발 방식:** 정적 컨텐츠, MVC, API의 차이점과 데이터를 다루는 법을 파악한다.
- **IoC & DI:** 객체 지향 설계의 핵심인 제어의 역전과 의존성 주입의 근본 원리를 이해한다.
- **AOP & PSA:** 관심사 분리와 서비스 추상화를 통해 유지보수성이 높은 코드를 설계한다.
- **빈(Bean) 관리:** 스프링 컨테이너의 역할과 싱글톤 스코프의 멀티스레드 위험성을 인지한다.

---

## 📝 주요 개념 정리

### 1. 서버 환경의 변화와 웹 개발 방식
- **WAS와 JAR의 변화 (내장 서버 구조):**
  - **과거:** 별도의 WAS(Tomcat 등)를 서버에 직접 설치하고 `WAR` 파일을 배포했다. 서버 설정이 복잡하고 환경 일관성이 낮았다.
  - **현재:** 소스 코드 내부에 서버 라이브러리가 포함된 **내장 톰캣(Embedded Tomcat)** 방식이다. 빌드 결과물인 **JAR** 파일 안에 애플리케이션 코드와 서버 구동 로직이 모두 포함되어 있어, 도커 환경 등 어디서든 `java -jar` 명령만으로 즉시 구동된다.

- **웹 개발의 3가지 방식과 데이터 전달:**
  - **정적 컨텐츠:** 서버 가공 없이 `/static` 폴더의 파일을 그대로 반환한다. (서버 로직 X)
  - **MVC와 템플릿 엔진:** 컨트롤러가 파라미터로 받은 `Model` 객체(데이터 상자)에 `model.addAttribute()`로 데이터를 담아 뷰(View)로 넘긴다. 뷰 리졸버는 이 상자의 데이터를 꺼내 HTML에 끼워 넣는다.
  - **API (JSON):** `@ResponseBody`를 통해 객체를 JSON으로 전달한다. 데이터뿐만 아니라 HTTP 상태 코드와 헤더를 정밀하게 제어할 수 있는 **`ResponseEntity`** 방식을 주로 선호한다. (@RestController를 클래스 상단에 붙여 모든 메소드에 @ResonseBody가 자동으로 적용된 것으로 간주함)

### 2. Application Context와 빈(Bean)
- **빈(Bean):** 개발자가 직접 `new`로 만든 객체가 아니라, 스프링이 생성부터 소멸까지 관리하는 스프링의 자바 객체를 말한다.
- **Application Context:** 이 빈들을 보관하고 조립하는 스프링 창고이자 관리자이다.
- **IoC & DI의 본질:** 클래스 내부에서 구현체를 직접 생성하면 강한 결합이 생겨 변경이 어렵다. 창고(ApplicationContext)에 있는 객체를 외부에서 주입(DI)받음으로써, 인터페이스에만 의존하게 하여 코드의 유연성을 극대화한다.

### 3. AOP(관점 지향 프로그래밍)와 PSA(서비스 추상화)
- **AOP(Aspect-Oriented Programming):** 로깅, 트랜잭션 등 반복되는 공통 관심사를 비즈니스 로직에서 분리한다. 스프링은 **프록시 패턴**을 사용하여 가짜 객체가 로직을 가로채 부가 기능을 실행하게 한다.
- **PSA(Portable Service Abstraction):** 하부 기술(JDBC, JPA 등)이 바뀌어도 동일한 인터페이스로 접근 가능하게 추상화 계층을 제공하는 것이다. (예: DB 접근 기술을 바꿔도 서비스 코드는 유지됨)

### 4. 싱글톤 빈의 멀티스레드 위험성
- **싱글톤 공유:** 스프링 빈은 기본적으로 하나만 생성되어 모든 사용자가 공유한다.
- **위험성:** 빈 내부에 특정 사용자의 정보를 저장하는 가변 필드(멤버 변수)가 있으면, 여러 사용자가 동시에 접속할 때 데이터가 덮어씌워지는 경합 상태(Race Condition)가 발생한다. 
- **설계 원칙:** 따라서 싱글톤 빈은 반드시 무상태(Stateless)로 설계해야 하며, 데이터는 메서드 내부의 **지역 변수**나 **파라미터**를 통해 다뤄야 안전하다.

---

## 💻 코드 실습 및 분석

### 1. 동시성 제어를 고려한 리포지토리 설계
스프링 빈은 싱글톤으로 공유되므로, 메모리 기반 저장소 구현 시 일반적인 자료구조를 사용하면 데이터 정합성이 깨질 수 있다.

```java
// repository/MemoryMemberRepository.java
public class MemoryMemberRepository implements MemberRepository {
    
    /**
     * [Why? ConcurrentHashMap과 AtomicLong을 쓰는 이유]
     * 문제상황: 웹 서버(Tomcat 등)는 수많은 사용자의 요청을 처리하기 위해 멀티스레드(Multi-thread) 방식을 사용함.
     * 각 요청마다 별도의 스레드가 할당되지만, 이 스레드들이 접근하는 스프링 빈(싱글톤 객체)은 단 하나임
     * 여러 스레드가 동시에 싱글톤 객체의 필드(멤버 변수)를 수정하려고 할 때 경합 상태(Race Condition) 발생
     * 만약 싱글톤 객체에서 어쩔 수 없이 상태를 관리하거나 변경해야 한다면, 일반적인 변수가 아닌 동시성을 보장하는 도구를 사용
     * 1. ConcurrentHashMap: 일반 HashMap은 동기화 처리가 없어 멀티스레드 환경에서 데이터가 깨질 수 있다. 
     * 이 자료구조는 버킷 단위로 락을 걸어 성능과 안정성을 모두 챙긴다.
     * 2. AtomicLong: 'sequence++' 연산은 원자적이지 않아 중복 ID가 생성될 위험이 있다. 
     * AtomicLong은 하드웨어 수준의 원자적 연산을 보장하여 중복을 방지한다.
     */
    private static Map<Long, Member> store = new ConcurrentHashMap<>();
    private static AtomicLong sequence = new AtomicLong(0L);

    @Override
    public Member save(Member member) {
        member.setId(sequence.incrementAndGet()); // 중복 방지 증가
        store.put(member.getId(), member);
        return member;
    }
}
```
- 무상태로의 구현이 베스트이지만, Repository(데이터를 저장 및 기억)는 특성 상 어쩔 수 없이 상태를 가져가야함 -> 동시성 제어를 선택
- 만약 Map의 지역변수로 만든다면, 메소드 종료 후에 바로 스택 영역에서 삭제되기에 어쩔 수 없이 클래스의 필드에 데이터를 힙 영역에 저장 (stateful)
- Service 클래스는 계산로직만 수행하고, 데이터를 지역 변수에만 담았다가 리턴하므로 무상태로 구현 가능 (stateless)
  - 무상태 구현
    - 지역 변수 사용: 메서드 내에서 선언된 변수(지역 변수)는 각 스레드마다 개별적으로 할당되는 스택(Stack) 영역에 저장된다. 따라서 여러 스레드가 동시에 들어와도 서로 절대 간섭할 수 없다.
    - 읽기 전용 필드: private final과 같이 초기화 이후 값이 변하지 않는 필드는 공유해도 안전 (예: 다른 서비스 객체의 주입값)


### 2. PSA 리팩토링 사례: 인증 추상화 (@LoginUser)
- PSA 정의: 하위 기술이 바뀌어도 상위 코드(컨트롤러 등)는 변하지 않게 하는 것
- 사례: 쿠키 파싱이라는 구체적인 기술을 어노테이션 뒤로 숨겨 추상화함
  - 추후에 쿠키 파싱이 다른 방식으로 변경되더라도, 컨트롤러 코드는 수정할 필요가 없어짐. 새로운 어노테이션을 선언한 ArgumentResolver 만 수정하면 된다!

* **What:** 각 컨트롤러에 흩어졌던 쿠키 파싱 로직을 `@LoginUser` 어노테이션으로 대체.
* **Why:** 컨트롤러가 기술적 디테일(쿠키 파싱 등)을 몰라도 되게 하여 비즈니스 로직에 집중하게 함.
* **When:** 여러 컨트롤러에서 공통적으로 로그인 정보가 필요할 때.
* **How:** `HandlerMethodArgumentResolver`를 구현하여 인증 로직 분리.
* **PSA 관점:** 향후 인증 방식이 JWT나 세션으로 바뀌어도, 컨트롤러 코드는 수정 없이 ArgumentResolver 내부만 바꾸면 되므로 확장성이 높다.

  <img width="982" height="196" alt="스크린샷 2026-01-21 14 36 10" src="https://github.com/user-attachments/assets/9bef1fcc-d264-40e4-ba9e-150ffd783065" />


```java
// 리팩토링 후 컨트롤러 예시
@GetMapping("/me")
public ResponseEntity<UserResponse> me(
    @LoginUser(required = false) Long userId // 내부 인증 방식이 추상화됨
) {
    if (userId == null) return ResponseEntity.noContent().build();
    
    Optional<User> u = service.findById(userId);
    return u.map(user -> ResponseEntity.ok(toDto(user)))
            .orElseGet(() -> ResponseEntity.noContent().build());
}
```
---
---

Q: WAS/JAR 배포 방식이 도커 환경에서 갖는 이점은?

A: 서버 설정을 이미지에 따로 할 필요 없이, 애플리케이션 자체가 서버를 품고 있으므로 java -jar 명령어 하나로 어디서나 동일한 실행 환경을 보장받는다.

Q: 순수한 자바 객체(POJO)에서 Getter/Setter는 왜 쓰는가?

A: 캡슐화(Encapsulation) 원칙을 지키기 위해서다. 필드에 직접 접근하는 것을 막고 메서드를 통해 데이터를 안전하게 읽고 저장하며, 필요시 유효성 검사 로직을 추가할 수도 있다.

Q: 싱글톤 빈의 의존성이 너무 많아지면 어떻게 하나?

A: 생성자 주입의 매개변수가 5~7개 이상 넘어간다면 해당 클래스가 너무 많은 책임을 지고 있다는 신호(SRP 위반)다. 기능별로 서비스를 분리하거나 파사드(Facade) 패턴을 검토해야 한다.

- 이번 주차 핵심 회고

스프링은 결국 개발자가 인프라 설정이나 중복 코드, 동시성 이슈 같은 기술적 스트레스에서 벗어나 비즈니스 가치에만 집중하게 돕는 도구임을 깨달았다. 특히 PSA를 직접 적용해보며 인터페이스 기반 설계의 강력함을 체감했다.
